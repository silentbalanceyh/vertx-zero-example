# 贪婪岛：Aeon

> 好风凭借力，送我上青云。——曹雪芹《临江仙·柳絮》

&ensp;&ensp;&ensp;&ensp;由于项目原因，Extension部分作为单点系统目前已运行了多个生产项目，一直想把这部分内容做个总结，但事实证明，这个工程量十分巨大，而且一直在重构和进行中，文档也许**严重滞后**，随着云端双项目的启动：

* 云端脚手架：<https://github.com/silentbalanceyh/vertx-zero-cloud>
* Zero数据标准：<http://www.vertx-cloud.cn/>

&ensp;&ensp;&ensp;&ensp;我打算换一种视角来讲Zero Extension的故事，对的，新故事的主角是**Aeon系统**，而故事的老主角依旧是**Zero Extension**（**它的故事慢慢补**），新版Zero重绘了架构图（参考：<https://gitee.com/silentbalanceyh/vertx-zero>），本章我们就敲开Aeon的大门。章节标题叫做《氷る世界（Ψυχρός κόσμος）》，起源于霜月遥的这首歌——又是一扇二次元的大门，而Aeon的名字起源于缇欧妹纸（零之轨迹角色）启动的永世系统，aeon本身翻译：**永世**。第一章叫**贪婪岛**是因为**不贪婪的人不会上云去玩**，而这个标题熟悉动漫的人也知道，这是《猎人》的第三章故事，一个虚拟的世界，类似于元宇宙的发源地。

&ensp;&ensp;&ensp;&ensp;Aeon系统最初的设计是为了上云，而又鉴于底层云平台在华为、腾讯、阿里三大平台上的高成本，所以只能万丈高楼平地起，从操作系统开始搭建底层系统，底层选择K8并非是追逐潮流，而是Zero最初的微架构就是搭建在gRPC和Etcd基础上准备玩Istio的（**了解Zero的人清楚，最开始它只是个玩具**），所以这次只是拿到古老的钥匙，开了当年哈迪斯残留在人间的潘多拉魔盒——重启`vertx-istio`项目罢了。这个故事很长，我没有信心能讲完，但我尽可能把Zero Extension和Aeon部分的内容娓娓道来，也许从这个视角，读者才明白Zero Extension的独特之处。

> 本章参考文档：<https://kubernetes.io/docs/home/>

## 1. 人生如初见

&ensp;&ensp;&ensp;&ensp;Aeon来到一个充满未知的世界，这个世界的名字叫做K8S（Kubernetes，来自希腊语“舵手”、“领航员”，8代表中间缩写了8个字母），带上您的初级装备，先把这个世界走一走（Zero中的第一个新角色叫做：[aeon-aurora](https://gitee.com/silentbalanceyh/vertx-zero/tree/master/vertx-istio/zero-edge/aeon-aurora)，aurora：黎明的女神），它的责任就是将zero中前后端统一打包成一个独立镜像，等待着K8S的召唤，独立镜像不意味着**大胖纸**——Zero Extension中的公共服务会逐渐从原始模块中抽象和分离出来形成云原生平台的共享服务，不过目前这种低等级时代，就先胖一胖。

> 真枪实弹的刀剑场，我会抛弃`minikube`环境（实验/学习环境之一），这个环境的搭建可直接参考官方教程以及在线的各种文档，本文直接搭建**生产环境**（3节点），并做下相关战斗记录。

&ensp;&ensp;&ensp;&ensp;本文环境信息如下：

| 项目           | 版本     |
| -------------- | -------- |
| CentOS         | 8.5.2111 |
| Kubernates     | 1.25     |
| Istio          |          |
| TiDB           |          |
| Vert.x Cluster | 4.3.3    |
| JDK            | 17.x     |
| Node           | 18.x     |

### 1.1. 容器运行时

* 参考：[移除 Dockershim 的常见问题](https://kubernetes.io/zh-cn/blog/2022/02/17/dockershim-faq/)

&ensp;&ensp;&ensp;&ensp;容器运行时（全称Container Runtime），它是一个负责运行容器的软件，使Pod可以运行在上面，K8S早期的版本仅适用于特定容器运行时：Docker Engine；之后K8S增加了其他容器运行时的支持，从1.5的版本开始创建了**容器运行时标准接口**（CRI，Container Runtime Interface），该标准主要是为了实现编排各种异构容器运行时并在其之间实现交互操作。

&ensp;&ensp;&ensp;&ensp;由于Docker Engine没有实现CRI，因此K8S团队尝试创建特殊代码来帮助它实现过渡，并且使`dockershim`代码成为K8S的一部分，由于`dockershim`是一个临时解决方案（参考[移除Dockershim的讨论](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim)），维护`dockershim`已成为了K8S运维团队的沉重负担，另外在最新的CRI运行时中实现了和`dockershim`不兼容的功能——所以`1.20`版本宣布，从`1.24`版本开始，dockershim正式从K8S项目中移除。

![](./_image/2022-09-10/20220910184626.png)[^1]

&ensp;&ensp;&ensp;&ensp;容器运行时是一个软件，主要用来组成K8S Pod的容器，K8S负责编排和调度Pod，在每一个节点上，kubelet工具使用抽象的容器运行时接口，所以您可以选用兼容的容器运行时，由于Docker是在CRI规范创建之前存在的，`dockershim`相当于K8S和Docker之间的一个适配器组件。

&ensp;&ensp;&ensp;&ensp;不论是Docker还是CRI，底层都调用了`Containerd`，它是一个工业级标准的容器运行时[^2]，强调**简单性、健壮性、可移植性**，它诞生于Docker——Docker作为一个完整的容器引擎，主要包含三部分，由统一的**Docker Daemon**进程提供（1.11开始）：

* 计算：`Containerd`提供
* 存储：`Docker-Volume`提供
* 网络：`Docker-Network`提供

![](./_image/2022-09-10/20220910190629.png)[^3]

&ensp;&ensp;&ensp;&ensp;当创建容器请求到达Docker Api，它会调用Containerd执行创建操作，此时Containerd会启动一个`containerd-shim`进程，该进程调用`runc`执行容器的创建；创建完成后，`runc`退出、`containerd-shim`作为容器的父进程收集运行状态并上报给`containerd`，并在容器中`pid`为`1`的进程退出后接管容器中的子进程执行清理以确保不会出现僵尸进程。

&ensp;&ensp;&ensp;&ensp;**为什么containerd不直接调用runc，而要启动一个containerd-shim调用runc**？因为容器进程是需要一个父进程来做状态收集、维持`stdin`等`fd`打开以及抽象层相关工作，若父进程是`Containerd`，它挂掉则整个宿主机上的所有容器都会退出，引入`containerd-shim`解决了这个问题，所以在早期`Containrd`一直是作为`Docker`创建容器的子组件而存在。

&ensp;&ensp;&ensp;&ensp;**何为`runc`**？很久很久以前……

&ensp;&ensp;&ensp;&ensp;**Round 1**[^4]：**Linux基金会 vs Docker**，2013年Docker开源了容器镜像格式和容器运行时，为业界提供了一种更轻量级、灵活的“计算、存储、网络”资源虚拟化和管理的解决方案，2014年容器技术引爆，各种容器编排工具也逐步发力，此时K8S的第一个Release版本也由Google发布。Docker容器的两项核心技术：**Namespace**（资源隔离）和**Cgroup**（资源管理）其并非Docker原创，而是很早就进入了Linux内核的东西，所以Docker的容器解决方案离不开Linux内核的支持：**倘若有人掌握了这两项技术，谁都可以做一套类似Docker的容器解决方案**。

&ensp;&ensp;&ensp;&ensp;容器技术的引爆，使得Docker容器镜像和容器运行时当时成为了行业标准，Docker成为了行业新星，它面对各个行业**神魔**（Linux基金会、Google、微软等）提出的合作邀请充耳不闻，态度强硬且傲慢，力图独自主导容器生态的发展。由于Docker的运行时向下兼容性的问题导致口碑逐渐变差，于是各个**神魔**都打算另起炉灶自己干。Linux基金会联合这些**神魔**向Docker施压，最终Docker屈服，于2015年6月在Docker大会上推出容器标准，并成立了容器标准化组织（OCI、Open Container Initiative），并发展成Linux基金会下的一个项目。OCI标准主要包含两部分：

* 容器运行时规范（runtime-spec）：定义了如何根据对应配置构造容器运行时。
* 容器镜像规范（image-spec）：定义了容器运行时使用的镜像打包规范。

&ensp;&ensp;&ensp;&ensp;而`runC`就是这两个规范落地的实体，它是一个符合OCI规范的轻量级容器运行时生命周期管理工具，最初也是Docker贡献给社区，来源于Docker原始的运行时管理部分，您可以运行`runC -h`查看帮助文档，它提供了生命周期管理、暂停、恢复、热迁移、状态查询等具体细节操作，使用`runC`创建和管理容器比较简单，解决了容器最核心、最底层、最基础的问题。

&ensp;&ensp;&ensp;&ensp;**Round 2**：**K8S vs Docker**，K8S的诞生正是Docker如日中天之时，那时它没有办法和Docker正面对决，只能通过硬编码的方式在`kubelet`工具中调用Docker API创建容器。OCI的诞生给了Google一把利刃，于是从K8S 1.5开始，它创建了容器运行时接口CRI，本质上就是K8S定义了一组和容器运行时交互的接口，所以只要实现了这套接口的容器运行时都可以直接对接K8S，由于当时CRI没有如今这种统治地位，有部分容器没有实现CRI接口，于是就有了`shim`（垫片）项目，一个`shim`的职责就是作为适配器将各种容器运行时本身的接口适配到K8S的CRI接口上，而`dockershim`就是K8S对接Docker到CRI接口上的一个实现。

&ensp;&ensp;&ensp;&ensp;OCI标准提出后，Red Hat的一些人开始设计和构建一个更简单的运行时，这个运行时仅为K8S使用，于是就有了`skunkworks`项目，最后这个项目定名为`CRI-O`——它实现了一个最小的CRI接口——引用原话：**CRI-O被设计为比其他的方案都要小，遵从Unix只做一件事并把它做好的设计哲学，实现组件重用**[^5]。根据CRI-O开发者的研究报告，这个项目最开始服务于`OpenShift`平台，同时得到了Intel和SUSE的支持，CRI-O和CRI规范兼容，并与OCI和Docker镜像格式也兼容，`CRI-O 1.0`于2017年10月正式发布。

![](./_image/2022-09-11/20220911100649.png)

&ensp;&ensp;&ensp;&ensp;于是2017年，Docker公司将容器运行时Containerd贡献给了CNCF，为了将Containerd接入到CRI标准中，K8S成立了`cri-containerd`项目，它是一个单独的守护进程，直接实现了`kubelet`和`containerd`之间的交互，形成了`Containerd 1.0`的样子，之后`cri-containerd`又被改造成了`Containerd`的CRI插件位于内部，K8S启动更加高效，就形成了如下结构：

![](./_image/2022-09-11/20220911103452.png)

&ensp;&ensp;&ensp;&ensp;再加上CRI-O的催化，直接兼容CRI和OCI规范，最终结果都比`dockershim`得方式接入K8S简单，于是这场战役以Docker失败告终。综合提到的`runC, OCI, CRI-O, Containerd, CRI`，它们的完整结构如如下[^6]：

![](./_image/2022-09-11/20220911103802.png)

&ensp;&ensp;&ensp;&ensp;Docker和K8S的战争中，Google最初只是一个独角戏，而[云原生计算基金会](https://www.cncf.io/)（CNCF, Cloud Native Computing Foundation）带来的社区力量改变了这一切，它成立的目的是构建“云原生”计算并推动其落地，这是一种围绕**微服务、容器、动态调度**以基础设施架构为中心的方式，这种风格就是通常我们提到的FIFEE（Google's Infrastructure For Everyone Else）：为其他所有人用的Google基础设施。

&ensp;&ensp;&ensp;&ensp;回顾Docker这位屠龙少年，虚拟化技术从虚拟机转移到容器运行时，它以简洁优雅的方式出场即王炸直接将VMware旗下的Cloud Foundry斩于马下，`Build Once, Run Anywhere`这句致胜的法则就是Docker打败CF的秘诀，加上Docker对开发人员的友好性，夺取了当之无愧的C位。而它在拿到融资之后，开始大量收购（DockerCompose, Docker Swarm, DockerMachine），从此这位开源的屠龙少年开始进行了商业化进程，释放的信号是未来的云厂商需要向Docker公司支付授权费用，过早暴露的商业化意图也为自己埋下了隐患。OCI基金会的成立被少年的傲慢忽略了，当时的它并没把OCI放在眼里，凭借自身的用户优势对**标准**漠不关心，OCI虽然在Docker缺席中发展缓慢，而之后的CNCF的成立却给OCI打了一剂强心针，也将K8S正式推出了舞台。之后的故事就没有什么可讲的了，Docker输在了视觉上：如果说Docker Swarm编排只是站在了容器视觉处理问题，而K8S则只是将容器定位为运行时环境（**容器运行时**），Pod和Service才是编排建模中的重点，只要符合标准的容器运行时都可以被Pod编排；如果说Docker打败CF依靠的是简洁，那么K8S打败Docker就是真正意义上的**降维打击**。有了这样的优势，K8S从

[^1]: [Docker依赖详解](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-removal-affects-you/)


[^2]: [Containerd的前世今生](https://blog.csdn.net/weixin_30641567/article/details/123838705)，作者：[班婕妤](https://banjieyu.blog.csdn.net/?type=blog)


[^3]: [Let's deeply understand how to run a container](https://blog.caoyu.info/docker-world.html)，作者：[紫玄](https://blog.caoyu.info/)


[^4]: [浅析容器运行时奥秘——OCI标准](https://zhuanlan.zhihu.com/p/478237201)


[^5]: [轻量级容器运行时 CRI-O 解析](https://blog.csdn.net/ccy19910925/article/details/118386726)，作者：[挖煤工人学IT](https://blog.csdn.net/ccy19910925?type=blog)

[^6]: <https://shenxianpeng.github.io/2022/03/container-ecosystem/>，作者：[Peter Shen](https://shenxianpeng.github.io/)

