---
title: 1-06. 注释 & 文档
---

# 1. 基本

## 1.1. 语法

Java语言中的注释有三种：

- **单行注释**

    ```java
    // 这是单行注释
    ```
- **多行注释**

    ```java
    /*
     * 这是多行注释
     */
    ```
- **文档注释**

    ```java
    /**
     * 概要描述
     * <p>
     * 详细描述
     * </p>
     * @标签
     */
    ```

## 1.2. 场景

Java中的**单行注释**和**多行注释**一般用于方法内，如：

![示例](images/006-comment-demo.png)

- 一般情况下，在您的注释不需要追加时，直接使用 `//` 的单行注释对代码进行说明。
- 方法内部 `/**/` 的多行注释会用得很多，但多行注释的格式本身可以是**多行**，也可以是**单行**，更多开发过程提倡直接使用 `/* xxx */` 的格式代替 `//` 的单行注释。

> 其实从实战过程中发现，单行注释的使用频率并不是特别高，**它**更适合注释部分有结论的备注，对于很多位置不一定带有结论的注释，需要使用 `/* xxx */` 留空，由于后期可能注释部分越发负责，所以这样的方式会让您的注释出现堆积，那么最好的方式就是先试用**多行注释**格式代替 `//` 单行的格式，后续直接使用单个回车就转换成对应格式了。

## 1.3. 文学化编程

**文学化**编程是《代码大全》和《编程匠艺》中提倡的一种编程范式，全称为 `Literate Programming`，它将编程语言和文档语言组合，使得程序可以达到如下两个核心目的：

- 程序可以被计算机执行。
- 程序可以被人阅读和理解。

这种编程的主要思想是把程序当做一种文学作品，用人的语言而不单纯是计算机的语言的逻辑和思路，它的优点是工程库程序可读性、可维护性、可重用性，也可以增加程序员的创造性和乐趣。

## 1.4. 底层思路

除了**文学化**编程的范式以外，您还需要在编程设计过程中使用底层思维进行编程，这种编程方式不是一种范式，而是要求程序员从硬件的角度出发，理解计算机的底层原理和机制，利用这些原理和机制来设计和实现程序，提高程序的性能、可移植性、执行效率，通过这种方式增强工程师解决和分析问题的能力。

如Java中常考虑的点（**未列全**）：

- 内存的开销。
- 对象的数量、符号引用的数量。
- JVM是否会自动对齐，还是需要手动对齐。
- 底层是否开启缓存（只要可防止二次加载和二次创建都可以考虑）。
- 是否将**强引用**改成**软引用**或**弱引用**。
- 最终编译好的代码是否会被JIT编译器优化。
- 打包的 `jar` 尺寸。
- 是否大概率出现挂起的**符号引用**。

> 初级程序员和高级程序员很大一层的区别在于编程过程的思维模式，虽然写出来的Java代码类似，但您会发现从底层思路上看计算机更能理解高级程序员写的代码。可能你会觉得现代硬件的成熟度已经不需要考虑这些内容了，但若您目前的程序是在一台嵌入式设备上运行（存储不够、内存不够、GC不全、实时性很高），可能您就不得不考虑这样的问题了，服务器集群下的程序不用如此粒度，而一旦上了硬件微端设备，计算机对上述点的改动是十分敏感的。

举个例子，参考代码：

```java 
        final List<String> data = new ArrayList<>();
        data.add("A");
        data.add("B");
        // 迭代1
        for(int idx = 0; idx < data.size(); idx++ ){
            final String name = "Name " + idx;
            System.out.println(name);
        }
        // 迭代2
        final int size = data.size();
        for(int idx = 0; idx < size; idx++ ){
            final String name = "Name " + idx;
            System.out.println(name);
        }
```

上述代码中调用了 `data.size()` 来提取尺寸，按计算机本身的逻辑而言，此处要考虑的点在于：`size` 的计算模式：**实时运算**还是**缓存运算**——当然很多底层写法对现代新版的语言不一定生效，但最终是否有效取决于源代码中的内容，参考 `ArrayList` 中的源代码：

```java 
/**
 * Returns the number of elements in this list.
 *
 * @return the number of elements in this list
 */
public int size() {
  return size;
}
```

上述代码说明上述两种带索引的迭代的方式没有任何所谓的**性能差异**，但若是 `Class` 中的 `getSimpleName()` 方法，那么就会有所不同：

```java 
/**
 * Returns the simple name of the underlying class as given in the
 * source code. An empty string is returned if the underlying class is
 * {@linkplain #isAnonymousClass() anonymous}.
 * A {@linkplain #isSynthetic() synthetic class}, one not present
 * in source code, can have a non-empty name including special
 * characters, such as "{@code $}".
 *
 * <p>The simple name of an {@linkplain #isArray() array class} is the simple name of the
 * component type with "[]" appended.  In particular the simple
 * name of an array class whose component type is anonymous is "[]".
 *
 * @return the simple name of the underlying class
 * @since 1.5
 */
public String getSimpleName() {
  ReflectionData<T> rd = reflectionData();
  String simpleName = rd.simpleName;
  if (simpleName == null) {
    rd.simpleName = simpleName = getSimpleName0();
  }
  return simpleName;
}
```

上述代码中的 `getSimpleName()` 从代码上看它会在每次调用时都会重新计算一次，当然由于新版JDK中使用了 `ReflectionData` 对元数据解析的内容做了缓存，所以此处你可以理解为底层已处理了缓存，但此处若您每次都调用 `getSimpleName()` 方法依旧可以产生开销：**创建局部 `simpleName` 符号引用**，只是这种开销是可以忽略的。

# 2. `javadoc` 命令























